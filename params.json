{"name":"Lustre","tagline":"An imperfect but more performant implementation of the Result pattern in Swift.","body":"# Lustre\r\n\r\nAn imperfect but more performant implementation of the Result pattern in Swift.\r\n\r\nLustre defines an interface with several manual specializations to improve\r\ncompiler inference and and runtime performance over a `Box<T>`-based Result\r\ntype, such as that from [LlamaKit](https://github.com/LlamaKit/LlamaKit).\r\n\r\nDay-to-day syntax of using Lustre's Result types are almost identical, except\r\nin that you must chose specific types to use for Result instances.\r\n\r\n`VoidResult` and `ObjectResult` are fully-implemented specializations ready\r\nfor use out of the box with no-return results and reference type results,\r\nrespectively.\r\n\r\n`AnyResult` is a fallback for any value type. `Any` is used as storage of any\r\n`T`. Types under 17 bytes in size will be stored inline, so results of\r\nall primitive types and most Swift collection types will have the same\r\nperformance of a specialized generic enum. Larger types are stored using a\r\nnative buffer type internal to Swift.\r\n\r\nThe `CustomResult` protocol exists for manual specializations for custom types\r\nof a known size. For example, a JSON-parsing library might provide a `JSON`\r\nenum, and `JSONResult` would conform to `CustomResult` with a `.Success(JSON)`\r\ncase.\r\n\r\nThe common-case implementation of `Result<T>` is clearly the way forward. Until\r\nSwift supports multi-payload generic enums, `Lustre.Result` mitigates the\r\nperformance problems around using a `Box<T>`-based Result type.\r\n\r\n## Availability\r\n\r\nLustre is intended for Swift 1.2. Compatibility with future versions is not\r\nguaranteed.\r\n\r\n## What's up with the name?\r\n\r\nResult `=>` Lustre. It's an anagram.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}