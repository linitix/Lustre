{"name":"Lustre","tagline":"A protocol-oriented Either and Result for Swift 2.0.","body":"Lustre is a more protocol-oriented variant of the nascent `Result` pattern in\r\nSwift 2.0, as seen commonly [in the community](https://github.com/antitypical/Result).\r\n\r\nLustre provides a protocol, `EitherType`, as well as two concrete\r\nimplementations, `Either<T, U>` and `Result<T>`.\r\n\r\n* The protocol is Swift-oriented and provides common functionality to monadic\r\n  types such as equatability and case analysis.\r\n* The `Either` type is modelled after the same name in Scala or Haskell. By\r\n  convention, the \"Left\" case is a failure or negative scenario, but `Either`\r\n  is more generally designed around any switch between two first-class values.\r\n* The `Result` type is related to the type of the same name in Haskell, and can\r\n  be considered a specialization of `Either` designed for compatibility with\r\n  Swift's error-handling. Its `Failure` case takes `ErrorType`, and convenience\r\n  methods are provided for conversion to and from Swift error handling syntax.\r\n\r\n## Why the Protocol?\r\n\r\nA good chunk of the time, you'll be using the concrete `Either` and `Result`.\r\nLike the design of Swift's `map` and `flatMap`, the default implementations of\r\n`map` and `flatMap` return a `Result`.\r\n\r\nMaking your own `EitherType` is useful for API design, when you want to model\r\nspecific scenarios but also get the convenience of an `Either` API. This\r\nincludes types not strictly represented by an enum with two cases, or a wrapper\r\nof another result, etc.\r\n\r\nIt might be advantageous to make your own concrete type conforming to\r\n`EitherType` and give it extra functionality. Consider an idiomatic `JSON`\r\nenum type. A JSON parser might return a `JSONResult`. On that type, you could\r\nhave convenience methods to return a `Result<String>` if the JSON value is the\r\nstring case, etc. But by conforming to `EitherType`, it is also mostly\r\ninterchangeable with any `Result` instance.\r\n\r\nThe need for this repo can go away if extensions with `where` cases are added\r\nto generics to parallel protocol extensions. See [rdar://21901489](http://www.openradar.me/radar?id=4677878595715072).\r\nUntil then, Lustre is a scalable, usable, and idiomatic version of the pattern\r\nyou already know and more-or-less tolerate. Unlike previous versions of Lustre,\r\nthere are no weird hacks, no `Any`, and no syntactical difference from the\r\ncommon-case `Result` type.\r\n\r\n## Availability\r\n\r\nLustre, on this branch, is intended for Swift 2.0. The old hacky version for\r\nSwift 1.2 is still [preserved](https://github.com/zwaldowski/Lustre/tree/swift-1_2).\r\n\r\n## What's up with the name?\r\n\r\nResult `=>` Lustre. It's an anagram.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}